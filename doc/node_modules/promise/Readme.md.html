<!DOCTYPE html>
<html>
<head>
  <title>Readme.md</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="../../doc-style.css" />
  <script src="../../doc-filelist.js"></script>
  <script>
    var relativeDir = "../../";
    var thisFile = "node_modules\\promise\\Readme.md";
    var defaultSidebar = true;
  </script>
  <script src="../../doc-script.js"></script>

</head>
<body>
  <div id="sidebar_wrapper">
    <div id="sidebar_switch">
      <span class="tree">Files</span>
      <span class="headings">Headings</span>
    </div>
    <div id="tree"></div>
    <div id="headings">

      <div class="heading h1">
        <a href="#promise">promise</a>
      </div>

      <div class="heading h2">
        <a href="#installation">Installation</a>
      </div>

      <div class="heading h2">
        <a href="#usage">Usage</a>
      </div>

      <div class="heading h2">
        <a href="#unhandled-rejections">Unhandled Rejections</a>
      </div>

      <div class="heading h2">
        <a href="#api">API</a>
      </div>

      <div class="heading h3">
        <a href="#new-promise-resolver">new Promise(resolver)</a>
      </div>

      <div class="heading h3">
        <a href="#static-functions">Static Functions</a>
      </div>

      <div class="heading h4">
        <a href="#promise.resolve-value">Promise.resolve(value)</a>
      </div>

      <div class="heading h4">
        <a href="#promise.reject-value">Promise.reject(value)</a>
      </div>

      <div class="heading h4">
        <a href="#promise.all-array">Promise.all(array)</a>
      </div>

      <div class="heading h4">
        <a href="#promise.denodeify-fn">Promise.denodeify(fn)</a>
      </div>

      <div class="heading h4">
        <a href="#promise.nodeify-fn">Promise.nodeify(fn)</a>
      </div>

      <div class="heading h3">
        <a href="#prototype-methods">Prototype Methods</a>
      </div>

      <div class="heading h3">
        <a href="#promisethen-onfulfilled-onrejected">Promise#then(onFulfilled, onRejected)</a>
      </div>

      <div class="heading h4">
        <a href="#promisecatch-onrejected">Promise#catch(onRejected)</a>
      </div>

      <div class="heading h4">
        <a href="#promisedone-onfulfilled-onrejected">Promise#done(onFulfilled, onRejected)</a>
      </div>

      <div class="heading h4">
        <a href="#promisenodeify-callback">Promise#nodeify(callback)</a>
      </div>

      <div class="heading h2">
        <a href="#license">License</a>
      </div>

    </div>
  </div>
  <div id="sidebar-toggle"></div>
  <div id="container">
    <div class="docs markdown"><p><a href="https://promisesaplus.com/"><img src="https://promisesaplus.com/assets/logo-small.png" align="right" /></a></p>
<div class="pilwrap" id="promise">
  <h1>
    <a href="#promise" name="promise" class="pilcrow"></a>
promise
  </h1>
</div>
<p>This is a simple implementation of Promises.  It is a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</p>
<p>For detailed tutorials on its use, see www.promisejs.org</p>
<p><strong>N.B.</strong> This promise exposes internals via underscore (<code>_</code>) prefixed properties.  If you use these, your code will break with each new release.</p>
<p><a href="https://travis-ci.org/then/promise"><img src="https://img.shields.io/travis/then/promise.svg?style=flat" alt="travis"></a>
<a href="https://david-dm.org/then/promise"><img src="https://img.shields.io/david/then/promise.svg?style=flat" alt="dep"></a>
<a href="https://npmjs.org/package/promise"><img src="https://img.shields.io/npm/v/promise.svg?style=flat" alt="npm"></a>
<a href="https://npmjs.org/package/promise"><img src="https://img.shields.io/npm/dm/promise.svg?style=flat" alt="downloads"></a></p>
<div class="pilwrap" id="installation">
  <h2>
    <a href="#installation" name="installation" class="pilcrow"></a>
Installation
  </h2>
</div>
<p><strong>Server:</strong></p>
<pre><code>$ npm install promise
</code></pre>
<p><strong>Client:</strong></p>
<p>You can use browserify on the client, or use the pre-compiled script that acts as a polyfill.</p>
<pre><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.promisejs.org/polyfills/promise-6.1.0.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Note that the <a href="https://github.com/es-shims/es5-shim">es5-shim</a> must be loaded before this library to support browsers pre IE9.</p>
<pre><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<div class="pilwrap" id="usage">
  <h2>
    <a href="#usage" name="usage" class="pilcrow"></a>
Usage
  </h2>
</div>
<p>The example below shows how you can load the promise library (in a way that works on both client and server using node or browserify).  It then demonstrates creating a promise from scratch.  You simply call <code>new Promise(fn)</code>.  There is a complete specification for what is returned by this method in <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+</a>.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'promise'</span>);

<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
  <span class="hljs-keyword">get</span>('http://www.google.com', function (err, res) {
    <span class="hljs-keyword">if</span> (err) reject(err);
    <span class="hljs-keyword">else</span> resolve(res);
  });
});
</code></pre>
<p>If you need <a href="https://iojs.org/api/domain.html">domains</a> support, you should instead use:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'promise/domains'</span>);
</code></pre>
<p>If you are in an environment that implements <code>setImmediate</code> and don't want the optimisations provided by asap, you can use:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'promise/setimmediate'</span>);
</code></pre>
<p>If you only want part of the features, e.g. just a pure ES6 polyfill:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'promise/lib/es6-extensions'</span>);
<span class="hljs-comment">// or require('promise/domains/es6-extensions');</span>
<span class="hljs-comment">// or require('promise/setimmediate/es6-extensions');</span>
</code></pre>
<div class="pilwrap" id="unhandled-rejections">
  <h2>
    <a href="#unhandled-rejections" name="unhandled-rejections" class="pilcrow"></a>
Unhandled Rejections
  </h2>
</div>
<p>By default, promises silence any unhandled rejections.</p>
<p>You can enable logging of unhandled ReferenceErrors and TypeErrors via:</p>
<pre><code class="js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'promise/lib/rejection-tracking'</span>).enable();
</code></pre>
<p>Due to the performance cost, you should only do this during development.</p>
<p>You can enable logging of all unhandled rejections if you need to debug an exception you think is being swallowed by promises:</p>
<pre><code class="js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'promise/lib/rejection-tracking'</span>).enable(
  {<span class="hljs-attr">allRejections</span>: <span class="hljs-literal">true</span>}
);
</code></pre>
<p>Due to the high probability of false positives, I only recommend using this when debugging specific issues that you think may be being swallowed.  For the preferred debugging method, see <code>Promise#done(onFulfilled, onRejected)</code>.</p>
<p><code>rejection-tracking.enable(options)</code> takes the following options:</p>
<ul>
<li>allRejections (<code>boolean</code>) - track all exceptions, not just reference errors and type errors.  Note that this has a high probability of resulting in false positives if your code loads data optimisticly</li>
<li>whitelist (<code>Array&lt;ErrorConstructor&gt;</code>) - this defaults to <code>[ReferenceError, TypeError]</code> but you can override it with your own list of error constructors to track.</li>
<li><code>onUnhandled(id, error)</code> and <code>onHandled(id, error)</code> - you can use these to provide your own customised display for errors.  Note that if possible you should indicate that the error was a false positive if <code>onHandled</code> is called.  <code>onHandled</code> is only called if <code>onUnhandled</code> has already been called.</li>
</ul>
<p>To reduce the chance of false-positives there is a delay of up to 2 seconds before errors are logged.  This means that if you attach an error handler within 2 seconds, it won't be logged as a false positive.  ReferenceErrors and TypeErrors are only subject to a 100ms delay due to the higher likelihood that the error is due to programmer error.</p>
<div class="pilwrap" id="api">
  <h2>
    <a href="#api" name="api" class="pilcrow"></a>
API
  </h2>
</div>
<p>Before all examples, you will need:</p>
<pre><code class="js"><span class="hljs-keyword">var</span> <span class="hljs-built_in">Promise</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'promise'</span>);
</code></pre>
<div class="pilwrap" id="new-promise-resolver">
  <h3>
    <a href="#new-promise-resolver" name="new-promise-resolver" class="pilcrow"></a>
new Promise(resolver)
  </h3>
</div>
<p>This creates and returns a new promise.  <code>resolver</code> must be a function.  The <code>resolver</code> function is passed two arguments:</p>
<ol>
<li><code>resolve</code> should be called with a single argument.  If it is called with a non-promise value then the promise is fulfilled with that value.  If it is called with a promise (A) then the returned promise takes on the state of that new promise (A).</li>
<li><code>reject</code> should be called with a single argument.  The returned promise will be rejected with that argument.</li>
</ol>
<div class="pilwrap" id="static-functions">
  <h3>
    <a href="#static-functions" name="static-functions" class="pilcrow"></a>
Static Functions
  </h3>
</div>
<p>These methods are invoked by calling <code>Promise.methodName</code>.</p>
<div class="pilwrap" id="promise.resolve-value">
  <h4>
    <a href="#promise.resolve-value" name="promise.resolve-value" class="pilcrow"></a>
Promise.resolve(value)
  </h4>
</div>
<p>(deprecated aliases: <code>Promise.from(value)</code>, <code>Promise.cast(value)</code>)</p>
<p>Converts values and foreign promises into Promises/A+ promises.  If you pass it a value then it returns a Promise for that value.  If you pass it something that is close to a promise (such as a jQuery attempt at a promise) it returns a Promise that takes on the state of <code>value</code> (rejected or fulfilled).</p>
<div class="pilwrap" id="promise.reject-value">
  <h4>
    <a href="#promise.reject-value" name="promise.reject-value" class="pilcrow"></a>
Promise.reject(value)
  </h4>
</div>
<p>Returns a rejected promise with the given value.</p>
<div class="pilwrap" id="promise.all-array">
  <h4>
    <a href="#promise.all-array" name="promise.all-array" class="pilcrow"></a>
Promise.all(array)
  </h4>
</div>
<p>Returns a promise for an array.  If it is called with a single argument that <code>Array.isArray</code> then this returns a promise for a copy of that array with any promises replaced by their fulfilled values.  e.g.</p>
<pre><code class="js"><span class="hljs-built_in">Promise</span>.all([<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'a'</span>), <span class="hljs-string">'b'</span>, <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'c'</span>)])
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
    assert(res[<span class="hljs-number">0</span>] === <span class="hljs-string">'a'</span>)
    assert(res[<span class="hljs-number">1</span>] === <span class="hljs-string">'b'</span>)
    assert(res[<span class="hljs-number">2</span>] === <span class="hljs-string">'c'</span>)
  })
</code></pre>
<div class="pilwrap" id="promise.denodeify-fn">
  <h4>
    <a href="#promise.denodeify-fn" name="promise.denodeify-fn" class="pilcrow"></a>
Promise.denodeify(fn)
  </h4>
</div>
<p><em>Non Standard</em></p>
<p>Takes a function which accepts a node style callback and returns a new function that returns a promise instead.</p>
<p>e.g.</p>
<pre><code class="javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">var</span> read = <span class="hljs-built_in">Promise</span>.denodeify(fs.readFile)
<span class="hljs-keyword">var</span> write = <span class="hljs-built_in">Promise</span>.denodeify(fs.writeFile)

<span class="hljs-keyword">var</span> p = read(<span class="hljs-string">'foo.json'</span>, <span class="hljs-string">'utf8'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{
    <span class="hljs-keyword">return</span> write(<span class="hljs-string">'foo.json'</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">JSON</span>.parse(str), <span class="hljs-literal">null</span>, <span class="hljs-string">'  '</span>), <span class="hljs-string">'utf8'</span>)
  })
</code></pre>
<div class="pilwrap" id="promise.nodeify-fn">
  <h4>
    <a href="#promise.nodeify-fn" name="promise.nodeify-fn" class="pilcrow"></a>
Promise.nodeify(fn)
  </h4>
</div>
<p><em>Non Standard</em></p>
<p>The twin to <code>denodeify</code> is useful when you want to export an API that can be used by people who haven't learnt about the brilliance of promises yet.</p>
<pre><code class="javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">Promise</span>.nodeify(awesomeAPI)
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">awesomeAPI</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">return</span> download(a, b)
}
</code></pre>
<p>If the last argument passed to <code>module.exports</code> is a function, then it will be treated like a node.js callback and not parsed on to the child function, otherwise the API will just return a promise.</p>
<div class="pilwrap" id="prototype-methods">
  <h3>
    <a href="#prototype-methods" name="prototype-methods" class="pilcrow"></a>
Prototype Methods
  </h3>
</div>
<p>These methods are invoked on a promise instance by calling <code>myPromise.methodName</code></p>
<div class="pilwrap" id="promisethen-onfulfilled-onrejected">
  <h3>
    <a href="#promisethen-onfulfilled-onrejected" name="promisethen-onfulfilled-onrejected" class="pilcrow"></a>
Promise#then(onFulfilled, onRejected)
  </h3>
</div>
<p>This method follows the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ spec</a>.  It explains things very clearly so I recommend you read it.</p>
<p>Either <code>onFulfilled</code> or <code>onRejected</code> will be called and they will not be called more than once.  They will be passed a single argument and will always be called asynchronously (in the next turn of the event loop).</p>
<p>If the promise is fulfilled then <code>onFulfilled</code> is called.  If the promise is rejected then <code>onRejected</code> is called.</p>
<p>The call to <code>.then</code> also returns a promise.  If the handler that is called returns a promise, the promise returned by <code>.then</code> takes on the state of that returned promise.  If the handler that is called returns a value that is not a promise, the promise returned by <code>.then</code> will be fulfilled with that value. If the handler that is called throws an exception then the promise returned by <code>.then</code> is rejected with that exception.</p>
<div class="pilwrap" id="promisecatch-onrejected">
  <h4>
    <a href="#promisecatch-onrejected" name="promisecatch-onrejected" class="pilcrow"></a>
Promise#catch(onRejected)
  </h4>
</div>
<p>Sugar for <code>Promise#then(null, onRejected)</code>, to mirror <code>catch</code> in synchronous code.</p>
<div class="pilwrap" id="promisedone-onfulfilled-onrejected">
  <h4>
    <a href="#promisedone-onfulfilled-onrejected" name="promisedone-onfulfilled-onrejected" class="pilcrow"></a>
Promise#done(onFulfilled, onRejected)
  </h4>
</div>
<p><em>Non Standard</em></p>
<p>The same semantics as <code>.then</code> except that it does not return a promise and any exceptions are re-thrown so that they can be logged (crashing the application in non-browser environments)</p>
<div class="pilwrap" id="promisenodeify-callback">
  <h4>
    <a href="#promisenodeify-callback" name="promisenodeify-callback" class="pilcrow"></a>
Promise#nodeify(callback)
  </h4>
</div>
<p><em>Non Standard</em></p>
<p>If <code>callback</code> is <code>null</code> or <code>undefined</code> it just returns <code>this</code>.  If <code>callback</code> is a function it is called with rejection reason as the first argument and result as the second argument (as per the node.js convention).</p>
<p>This lets you write API functions that look like:</p>
<pre><code class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">awesomeAPI</span>(<span class="hljs-params">foo, bar, callback</span>) </span>{
  <span class="hljs-keyword">return</span> internalAPI(foo, bar)
    .then(parseResult)
    .then(<span class="hljs-literal">null</span>, retryErrors)
    .nodeify(callback)
}
</code></pre>
<p>People who use typical node.js style callbacks will be able to just pass a callback and get the expected behavior.  The enlightened people can not pass a callback and will get awesome promises.</p>
<div class="pilwrap" id="license">
  <h2>
    <a href="#license" name="license" class="pilcrow"></a>
License
  </h2>
</div>
<p>MIT</p>
</div>
  </div>
</body>
</html>
